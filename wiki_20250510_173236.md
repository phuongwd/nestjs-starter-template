# Wiki Documentation

Generated on: 2025-05-10 17:32:36

## Table of Contents

- [Overview & Getting Started](#page-1)
- [System Architecture](#page-2)
- [Multi-tenancy & Organization Management](#page-3)
- [Authentication and Security](#page-4)
- [Subscription and Billing](#page-5)
- [Monitoring and Health Checks](#page-6)

<a id='page-1'></a>

## Overview & Getting Started

### Related Files

- `README.md`
- `Dockerfile`
- `docker-compose.yml`
- `.env.example`
- `package.json`

### Related Pages

Related topics: [System Architecture](#page-2)

# Overview & Getting Started

This section provides a guide to setting up and running the `nestjs-starter-template` repository locally. It focuses on the core files necessary to understand the template's structure and get the application operational quickly, primarily using Docker.

The template is designed to provide a robust starting point for building NestJS applications, incorporating common patterns and configurations. The files covered here facilitate initial setup, dependency management, environment configuration, and containerization for easy deployment and development.

## Core Files Analysis

### README.md

The `README.md` file serves as the primary documentation entry point. It provides a high-level overview of the project, instructions for setup, prerequisites, and commands to build and run the application. It's the first place users look to understand how to get started.

```markdown
# NestJS Starter Template

A robust NestJS starter template with best practices.

## Getting Started

### Prerequisites

- Node.js (v18+)
- Docker & Docker Compose

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/phuongwd/nestjs-starter-template.git
   cd nestjs-starter-template
   ```
2. Copy the example environment file:
   ```bash
   cp .env.example .env
   ```
3. Build and run with Docker Compose:
   ```bash
   docker-compose up --build
   ```
...
```

<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/README.md" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">README.md</a></p>

### package.json

The `package.json` file manages the project's dependencies, scripts, and metadata. It defines the required Node.js packages (dependencies and devDependencies) and provides script shortcuts for common development tasks like starting the development server, building the application, running tests, etc.

```json
{
  "name": "nestjs-starter-template",
  "version": "1.0.0",
  "description": "A robust NestJS starter template",
  "private": true,
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r jest/bin/run --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/platform-express": "^10.0.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "rimraf": "^5.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
```

<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/package.json" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">package.json</a></p>

### .env.example

The `.env.example` file provides a template for environment variables required by the application. It lists the configuration settings that should be provided in a `.env` file (which is typically ignored by Git) to configure the application's behavior for different environments (development, production, etc.).

```dotenv
# App
NODE_ENV=development
PORT=3000
API_PREFIX=api

# Database (Example - Adjust based on actual setup)
DATABASE_URL=postgresql://user:password@host:port/database
```

<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/.env.example" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">.env.example</a></p>

### Dockerfile

The `Dockerfile` contains instructions for building a Docker image of the NestJS application. It specifies the base image, copies the application code, installs dependencies, builds the application, and defines the command to run the application within the container.

```dockerfile
ARG NODE_VERSION=18
FROM node:${NODE_VERSION}-alpine AS base

# Install dependencies
FROM base AS deps
WORKDIR /app
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm install --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Build application
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

# Production image
FROM base AS runner
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package.json .
# Copy .env file if it exists (handle in docker-compose for dev)
# COPY .env .env

EXPOSE 3000
CMD [ "node", "dist/main" ]
```

<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/Dockerfile" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">Dockerfile</a></p>

### docker-compose.yml

The `docker-compose.yml` file defines the services, networks, and volumes for running the application using Docker Compose. It orchestrates multiple containers (e.g., the NestJS application and a database) and configures their interactions. It's the standard way to run the application locally in a containerized environment.

```yaml
version: '3.8'

services:
  app:
    container_name: nestjs_app
    build:
      context: .
      dockerfile: Dockerfile
      target: runner # Use the runner stage from the Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - .:/app # Mount source code for development (optional, depends on setup)
      - /app/node_modules # Prevent host node_modules from overwriting container ones
    env_file:
      - .env # Load environment variables from .env file
    # command: npm run start:dev # Use this for hot-reloading development
    # depends_on:
    #   - database # Example dependency on a database service

  # Example Database Service (Uncomment and configure as needed)
  # database:
  #   container_name: app_db
  #   image: postgres:13-alpine
  #   ports:
  #     - "5432:5432"
  #   environment:
  #     POSTGRES_USER: user
  #     POSTGRES_PASSWORD: password
  #     POSTGRES_DB: database
  #   volumes:
  #     - db_data:/var/lib/postgresql/data

# volumes:
#   db_data: # Example volume for database persistence
```

<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/docker-compose.yml" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">docker-compose.yml</a></p>

## Setup Workflow

The standard process for getting the template running involves cloning the repository, configuring environment variables, and using Docker Compose to build and run the application containers.

```mermaid
graph TD
    A([Start]) --> B[Clone Repository];
    B --> C[Copy .env.example to .env];
    C --> D[Configure .env File];
    D --> E[docker-compose.yml Reads Config];
    E --> F[Dockerfile Builds Image];
    F --> G[Docker Daemon Runs Containers];
    G --> H[Application Service Starts];
    H --> I[App Running on Port 3000];
    I --> Z([End]);
```

## Integration with Architecture

These files are fundamental to the initial setup and runtime environment.
*   `package.json` defines the core dependencies and build/run scripts used by the NestJS application itself, whether run natively or in Docker.
*   `.env.example` and `.env` provide the necessary configuration values that the NestJS application reads at runtime (often via a ConfigModule) to connect to databases, set ports, etc.
*   `Dockerfile` encapsulates the NestJS application and its dependencies into a portable image, ensuring a consistent environment.
*   `docker-compose.yml` orchestrates the NestJS application container (built from the Dockerfile) and potentially other services like a database, defining how they interact and their external access (port mapping).
*   `README.md` ties it all together by providing the human-readable instructions to use these files and start the system.

Together, they form the base layer for developing and deploying the NestJS application, abstracting away system-specific setup details through containerization.

---

<a id='page-2'></a>

## System Architecture

### Related Files

- `src/app.module.ts`
- `src/main.ts`
- `src/core/`
- `src/shared/`
- `prisma/schema.prisma`
- `src/modules/`

### Related Pages

Related topics: [Overview & Getting Started](#page-1), [Multi-tenancy & Organization Management](#page-3), [Authentication and Security](#page-4)

# System Architecture

The system architecture of the `nestjs-starter-template` repository follows a modular, layered approach based on the NestJS framework principles. It structures the application into distinct components responsible for specific concerns, promoting maintainability, scalability, and testability.

## Purpose and Functionality

The architecture is designed to provide a robust foundation for building scalable server-side applications using NestJS, TypeScript, and Prisma ORM. Key functionalities include:

*   **Application Entry Point:** Initializing and configuring the NestJS application.
*   **Module System:** Organizing application features into self-contained modules.
*   **Core Utilities:** Providing fundamental, application-wide services or configurations.
*   **Shared Resources:** Offering common types, DTOs, or helper functions used across modules.
*   **Database Interaction:** Defining the data model and handling database operations using Prisma.
*   **Request Handling:** Processing incoming requests through controllers, services, and repositories.

## Core Components

### `src/main.ts`

This file is the application's entry point. It uses `NestFactory` to create a NestJS application instance from the root module (`AppModule`). It typically includes global configurations like setting up CORS, global pipes (e.g., `ValidationPipe`), global interceptors, and starting the HTTP server.

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Apply global validation pipe
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
}
bootstrap();
```

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/main.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/main.ts</a>

### `src/app.module.ts`

The root module of the application. It imports all feature modules (`src/modules/*`) and potentially core or shared modules. It acts as the central configuration point, defining the initial structure and dependencies of the application graph.

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './modules/user/user.module';
import { AuthModule } from './modules/auth/auth.module';
import { PrismaModule } from './prisma/prisma.module';

@Module({
  imports: [
    UserModule,
    AuthModule,
    PrismaModule, // Example of importing a core/shared module
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/app.module.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/app.module.ts</a>

### `src/core/`

This directory typically contains application-wide infrastructure concerns. This might include global guards, interceptors, pipes, configuration services, or base classes that are fundamental and used across multiple features.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/core" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/core/</a>

### `src/shared/`

This directory holds common resources used throughout the application but not necessarily core infrastructure. Examples include Data Transfer Objects (DTOs), interfaces, enums, constants, or utility functions that are shared between different modules.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/shared" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/shared/</a>

### `prisma/schema.prisma`

This file defines the application's database schema using the Prisma Schema Language. It declares models, their fields, relationships, and database connections. Prisma client is generated based on this schema, providing a type-safe ORM for database interactions.

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/prisma/schema.prisma" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">prisma/schema.prisma</a>

### `src/modules/`

This directory contains feature-specific modules. Each subdirectory within `src/modules/` represents a distinct domain or feature (e.g., `auth`, `user`). A typical module includes a controller (handling HTTP requests), a service (containing business logic), and potentially a repository (interacting with the data layer, often via Prisma). Modules encapsulate related logic and can be imported into `AppModule` or other modules.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/</a>

## Integration Flow

The architecture integrates these components through NestJS's dependency injection system and module structure.

1.  **Request Entry:** An incoming HTTP request is received by the server managed by `main.ts`.
2.  **Application Bootstrap:** `main.ts` bootstraps the application using `AppModule`. Global pipes, guards, and interceptors defined in `main.ts` or provided globally via `AppModule` or `core/` are applied.
3.  **Routing:** NestJS's router, configured by controllers within modules imported by `AppModule`, directs the request to the appropriate controller method in `src/modules/*`.
4.  **Business Logic:** The controller delegates the request processing to a service within the same module (`src/modules/<feature>/<feature>.service.ts`). Services encapsulate the core business logic.
5.  **Data Access:** Services interact with the database layer, typically through a repository or directly using the Prisma client. The Prisma client is configured based on `prisma/schema.prisma`.
6.  **Shared/Core Utilities:** Services or controllers may utilize shared resources from `src/shared/` (like DTOs or helper functions) or core services/utilities from `src/core/`.
7.  **Response:** The result flows back from the database through the repository, service, and controller, eventually being sent back as an HTTP response via the mechanisms set up in `main.ts`.

This flow is illustrated in the sequence diagram below:

```mermaid
sequenceDiagram
  participant Client
  participant MainTS as main.ts
  participant AppModule as app.module.ts
  participant GlobalHandlers as Global Pipes/Guards
  participant FeatureModule as src/modules/*
  participant Controller as Controller
  participant Service as Service
  participant Repository as Repository
  participant CoreShared as src/core/ & src/shared/
  participant Prisma as Prisma ORM
  participant Database as Database

  Client->>MainTS: HTTP Request
  activate MainTS
  MainTS->>AppModule: Bootstrap App
  activate AppModule
  AppModule->>GlobalHandlers: Apply Global Handlers
  activate GlobalHandlers
  GlobalHandlers->>FeatureModule: Route to Module
  activate FeatureModule
  FeatureModule->>Controller: Handle Request
  activate Controller
  Controller->>Service: Call Service Method
  activate Service
  Service->>CoreShared: Use Core/Shared
  CoreShared-->>Service: Utility/Data
  Service->>Repository: Call Repository
  activate Repository
  Repository->>Prisma: Execute Query
  activate Prisma
  Prisma->>Database: Database Op
  activate Database
  Database-->>Prisma: Result
  deactivate Database
  Prisma-->>Repository: Data
  deactivate Prisma
  Repository-->>Service: Data
  deactivate Repository
  Service-->>Controller: Result
  deactivate Service
  Controller-->>FeatureModule: Response Data
  deactivate Controller
  FeatureModule-->>GlobalHandlers: Process Response
  deactivate FeatureModule
  GlobalHandlers-->>AppModule: Final Response
  deactivate GlobalHandlers
  AppModule-->>MainTS: Send Response
  deactivate AppModule
  MainTS-->>Client: HTTP Response
  deactivate MainTS


---

<a id='page-3'></a>

## Multi-tenancy & Organization Management

### Related Files

- `src/shared/middleware/tenant-context.middleware.ts`
- `src/modules/organizations/`
- `src/modules/permissions/`
- `src/shared/guards/permission.guard.ts`
- `src/shared/decorators/require-permissions.decorator.ts`
- `prisma/schema.prisma`

### Related Pages

Related topics: [System Architecture](#page-2), [Authentication and Security](#page-4)

# Multi-tenancy & Organization Management

This section details the implementation of multi-tenancy and organization management within the template, enabling the application to serve multiple distinct organizations (tenants) while maintaining data isolation and managing user permissions within those organizations.

## Purpose and Functionality

The core purpose is to allow users to belong to specific organizations and access resources or perform actions only permitted within their organization and based on their assigned permissions. This is achieved by:

*   Identifying the current tenant (organization) for each incoming request.
*   Filtering data queries based on the identified tenant.
*   Enforcing permissions based on the user's role and the required permissions for a specific route or action within the tenant context.
*   Providing modules for managing organizations and permissions.

## Key Components and Implementation

### Database Schema (`prisma/schema.prisma`)

The data model includes `Organization` and `User` models. A key aspect is the `organizationId` field on models that belong to a specific tenant, such as the `User` model, ensuring data is linked to an organization.

```prisma
// prisma/schema.prisma
model Organization {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     User[]
  // Other tenant-specific models would link here
}

model User {
  id             String        @id @default(uuid())
  email          String        @unique
  password       String
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id])
  // ... other user fields and relations
}
```

### Tenant Context Middleware (`src/shared/middleware/tenant-context.middleware.ts`)

This middleware runs on incoming requests to identify the organization the request belongs to. This is typically done by extracting information from the request, such as a header (`x-tenant-id`) or subdomain. The identified tenant ID is then stored in a request-scoped context (e.g., using `AsyncLocalStorage` or a custom request context service) for later use in services and guards.

```typescript
// src/shared/middleware/tenant-context.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { TenantContextService } from '../context/tenant-context.service'; // Assuming a service exists

@Injectable()
export class TenantContextMiddleware implements NestMiddleware {
  constructor(private readonly tenantContextService: TenantContextService) {}

  use(req: Request, res: Response, next: NextFunction) {
    // Example: Get tenant ID from header
    const tenantId = req.headers['x-tenant-id'] as string;

    if (tenantId) {
      this.tenantContextService.setTenantId(tenantId);
    } else {
      // Handle requests not associated with a tenant, if applicable
      this.tenantContextService.setTenantId(null);
    }

    next();
  }
}
```

### Organization Module (`src/modules/organizations/`)

This module handles the core business logic for managing organizations. It includes controllers, services, and repositories for operations like creating, reading, updating, and deleting organizations. Services within this module, and others, would typically use the tenant context to ensure operations are scoped to the current tenant.

### Permissions Module (`src/modules/permissions/`)

This module defines and manages the application's permission system. It might include models for `Permission`, `Role`, and a many-to-many relationship between them, potentially linked to users or user groups within an organization. Services here would provide methods to check if a user has a specific permission.

### Required Permissions Decorator (`src/shared/decorators/require-permissions.decorator.ts`)

This custom decorator is used on controller methods to specify which permissions are required to access that route. It stores metadata that the `PermissionGuard` can read.

```typescript
// src/shared/decorators/require-permissions.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const REQUIRED_PERMISSIONS_KEY = 'requiredPermissions';

export const RequirePermissions = (...permissions: string[]) =>
  SetMetadata(REQUIRED_PERMISSIONS_KEY, permissions);
```

### Permission Guard (`src/shared/guards/permission.guard.ts`)

This NestJS guard is applied globally or to specific routes. It retrieves the required permissions using the `@RequirePermissions` decorator's metadata, gets the current user and tenant from the request context, and uses the `PermissionsService` to check if the user within the current tenant context possesses the necessary permissions.

```typescript
// src/shared/guards/permission.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { REQUIRED_PERMISSIONS_KEY } from '../decorators/require-permissions.decorator';
import { PermissionsService } from '../../modules/permissions/permissions.service';
import { TenantContextService } from '../context/tenant-context.service'; // Assuming context service

@Injectable()
export class PermissionGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private permissionsService: PermissionsService,
    private tenantContextService: TenantContextService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(
      REQUIRED_PERMISSIONS_KEY,
      [context.getHandler(), context.getClass()],
    );

    if (!requiredPermissions) {
      return true; // No specific permissions required
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user; // Assuming user is attached by an auth guard

    if (!user) {
      return false; // No authenticated user
    }

    const tenantId = this.tenantContextService.getTenantId();

    if (!tenantId) {
        return false; // No tenant context established
    }

    // Check if the user has ALL required permissions within the tenant context
    return this.permissionsService.userHasPermissions(
      user.id,
      tenantId,
      requiredPermissions,
    );
  }
}
```

## Integration with Overall Architecture

Multi-tenancy and organization management are integrated at multiple layers:

1.  **Middleware Layer:** The `TenantContextMiddleware` is registered globally or for specific routes to establish the tenant context early in the request lifecycle.
2.  **Guard Layer:** The `PermissionGuard` is applied globally or per-route to enforce access control based on permissions within the established tenant context. It relies on metadata set by the `@RequirePermissions` decorator.
3.  **Service Layer:** Services across different modules (including `OrganizationsService`, `PermissionsService`, and services for other tenant-specific data) retrieve the current tenant ID from the request-scoped context (`TenantContextService`) to filter database queries and business logic, ensuring data isolation.
4.  **Database Layer:** The `prisma/schema.prisma` defines the relationships and fields (`organizationId`) necessary to link tenant-specific data to the `Organization` model. Prisma queries in services are augmented to include `where: { organizationId: currentTenantId }`.

This layered approach ensures that multi-tenancy and permission checks are consistently applied throughout the application, from request entry to data access.

```mermaid
sequenceDiagram
  participant Client
  participant NestJSApp
  participant TenantMiddleware
  participant AuthGuard
  participant PermissionGuard
  participant Controller
  participant Service
  participant Database

  Client->>NestJSApp: HTTP Request (with Tenant ID header)
  activate NestJSApp
  NestJSApp->>TenantMiddleware: Process Request
  activate TenantMiddleware
  TenantMiddleware->>TenantMiddleware: Extract Tenant ID
  TenantMiddleware->>TenantMiddleware: Store in Context
  TenantMiddleware-->>NestJSApp: Tenant Context Set
  deactivate TenantMiddleware

  NestJSApp->>AuthGuard: Check Authentication
  activate AuthGuard
  AuthGuard-->>NestJSApp: User Authenticated
  deactivate AuthGuard

  NestJSApp->>PermissionGuard: Check Permissions
  activate PermissionGuard
  PermissionGuard->>PermissionGuard: Get Required Permissions (from Decorator)
  PermissionGuard->>PermissionGuard: Get User & Tenant ID (from Context)
  PermissionGuard->>Service: Check User Permissions(userId, tenantId, perms)
  activate Service
  Service->>Database: Query Permissions Data (filtered by tenantId)
  activate Database
  Database-->>Service: Permissions Data
  deactivate Database
  Service-->>PermissionGuard: Has Permissions (true/false)
  deactivate Service
  PermissionGuard-->>NestJSApp: Access Granted/Denied
  deactivate PermissionGuard

  alt Access Granted
    NestJSApp->>Controller: Execute Handler
    activate Controller
    Controller->>Service: Perform Business Logic (using tenantId from context)
    activate Service
    Service->>Database: Query/Modify Data (filtered by tenantId)
    activate Database
    Database-->>Service: Data
    deactivate Database
    Service-->>Controller: Result
    deactivate Service
    Controller-->>NestJSApp: Response Data
    deactivate Controller
    NestJSApp-->>Client: HTTP Response
  else Access Denied
    NestJSApp--xClient: Forbidden Response (403)
  end
  deactivate NestJSApp
```

Sources:
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/shared/middleware/tenant-context.middleware.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/shared/middleware/tenant-context.middleware.ts</a></p>
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/organizations" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/organizations/</a></p>
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/permissions" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/permissions/</a></p>
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/shared/guards/permission.guard.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/shared/guards/permission.guard.ts</a></p>
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/shared/decorators/require-permissions.decorator.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/shared/decorators/require-permissions.decorator.ts</a></p>
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/prisma/schema.prisma" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">prisma/schema.prisma</a></p>

---

<a id='page-4'></a>

## Authentication and Security

### Related Files

- `src/modules/auth/`
- `src/shared/guards/jwt-auth.guard.ts`
- `src/shared/guards/throttler.guard.ts`
- `src/modules/admin/sessions/`
- `src/modules/system/setup/guards/setup-rate-limit.guard.ts`
- `src/modules/system/setup/guards/setup-security.guard.ts`

### Related Pages

Related topics: [System Architecture](#page-2), [Multi-tenancy & Organization Management](#page-3)

# Authentication and Security

This section details the authentication and security mechanisms implemented in the nestjs-starter-template repository, focusing on user authentication, authorization via guards, rate limiting, and specific security measures for system setup.

## Core Authentication and Authorization

The primary authentication method uses JSON Web Tokens (JWT). Once a user is authenticated (e.g., via login), a JWT is issued and used for subsequent requests to protected endpoints. Authorization is handled using NestJS Guards.

### Authentication Module (`src/modules/auth/`)

This module encapsulates the logic for user registration, login, token generation, and potentially token refresh or password reset flows. It interacts with user data storage and leverages Passport.js strategies (specifically JWT) for handling token verification.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/auth" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/auth/</a>

### JWT Authentication Guard (`src/shared/guards/jwt-auth.guard.ts`)

This guard extends `AuthGuard('jwt')` from `@nestjs/passport`. It is applied to routes that require a valid JWT. When a request arrives at a route protected by this guard, Passport attempts to validate the JWT provided in the request headers. If the token is valid, the user object is attached to the request, and the guard allows the request to proceed. Otherwise, it rejects the request, typically with a 401 Unauthorized status.

```typescript
// src/shared/guards/jwt-auth.guard.ts
import { ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    // Add your custom authentication logic here
    // For example, call super.logIn(request) to establish a session
    return super.canActivate(context);
  }

  handleRequest(err, user, info) {
    // This is where you would throw an exception based on the user, err, or info
    if (err || !user) {
      throw err || new UnauthorizedException();
    }
    return user;
  }
}
```

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/shared/guards/jwt-auth.guard.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/shared/guards/jwt-auth.guard.ts</a>

## Rate Limiting and Throttling

To protect against brute-force attacks and denial-of-service attempts, the application implements rate limiting.

### Throttler Guard (`src/shared/guards/throttler.guard.ts`)

This guard utilizes the `@nestjs/throttler` package to limit the number of requests a client can make within a specified time frame. It can be applied globally or per route/controller. The configuration for limits (e.g., max requests per minute) is typically defined in the application's configuration.

```typescript
// src/shared/guards/throttler.guard.ts
import { ThrottlerGuard as NestThrottlerGuard } from '@nestjs/throttler';
import { Injectable } from '@nestjs/common';

@Injectable()
export class ThrottlerGuard extends NestThrottlerGuard {
  // Custom logic can be added here if needed,
  // e.g., overriding handleRequest or getThrottlerOptions
}
```

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/shared/guards/throttler.guard.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/shared/guards/throttler.guard.ts</a>

### Setup Rate Limit Guard (`src/modules/system/setup/guards/setup-rate-limit.guard.ts`)

A specialized throttler guard potentially configured with different limits specifically for the initial system setup endpoints (`src/modules/system/setup/`). This adds an extra layer of protection to sensitive setup routes.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/modules/system/setup/guards/setup-rate-limit.guard.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/system/setup/guards/setup-rate-limit.guard.ts</a>

## Setup Specific Security

The system setup process often involves sensitive operations. Dedicated guards are used to protect these endpoints.

### Setup Security Guard (`src/modules/system/setup/guards/setup-security.guard.ts`)

This guard likely implements checks specific to the setup process, such as ensuring the setup has not already been completed, validating a setup token, or checking specific environment conditions before allowing access to setup endpoints. This prevents unauthorized or repeated execution of setup procedures.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/src/modules/system/setup/guards/setup-security.guard.ts" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/system/setup/guards/setup-security.guard.ts</a>

## Admin Session Management

### Admin Sessions Module (`src/modules/admin/sessions/`)

This module likely provides functionality for administrators to view and manage active user sessions. This could include listing current sessions, revoking sessions (e.g., logging a user out remotely), or viewing session details. While not part of the core authentication flow for a regular user request, it is a security feature for administrators.

Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/admin/sessions" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/admin/sessions/</a>

## Integration with Overall Architecture

Authentication and security are fundamental cross-cutting concerns in the NestJS architecture.

-   **Guards:** Guards are global or route-specific middleware components that execute *before* the route handler. They implement authorization logic based on criteria like JWT validity, user roles/permissions (if implemented), or request rate limits. They integrate by being bound to controllers or specific routes using decorators (`@UseGuards()`).
-   **Auth Module:** The `AuthModule` provides the services and controllers for handling the authentication process itself (login, register). It's typically imported into other modules that need authentication functionality.
-   **Throttler Module:** Configured globally or per feature module, the Throttler applies rate limits using the `ThrottlerGuard`.
-   **Setup Guards:** These are specifically applied to the routes within the `SystemSetupModule` to protect initial configuration endpoints.

The flow for a typical protected API request involves the request passing through the globally applied `ThrottlerGuard`, potentially setup-specific guards (if applicable), and then the `JwtAuthGuard` before reaching the controller method.

```mermaid
graph TD
    A([Client Request]) --> B[Throttler Guard]
    B --> C{Rate Limit Exceeded?}
    C -->|Yes| D(Reject 429)
    C -->|No| E[Setup Security Guard?]
    E -->|Yes| F{Setup Allowed?}
    F -->|No| D
    F -->|Yes| G[Jwt Auth Guard]
    E -->|No| G
    G --> H{JWT Valid?}
    H -->|No| I(Reject 401)
    H -->|Yes| J[Controller Method]
    J --> K(Process Request)
    K --> L([Send Response])


---

<a id='page-5'></a>

## Subscription and Billing

### Related Files

- `src/modules/subscriptions/`
- `prisma/schema.prisma`

### Related Pages

Related topics: [System Architecture](#page-2)

## Subscription and Billing

This section details the implementation of subscription and billing functionalities within the template, covering user subscriptions to various plans and associated data management.

### Purpose and Functionality

The subscription and billing component provides the core logic for managing user access based on different service plans. Its primary functions include:

*   Defining available subscription plans with features and pricing.
*   Allowing users to subscribe to a chosen plan.
*   Recording and tracking active user subscriptions.
*   Potentially handling payment integration callbacks (though specific payment gateway logic might be external or abstract).
*   Storing historical subscription data.

This module acts as the central point for managing user entitlements based on their purchased plan.

### Database Schema

The core data structure for subscriptions is defined in the Prisma schema. Key models include `Plan` and `Subscription`.

```prisma
// prisma/schema.prisma

model Plan {
  id          String        @id @default(uuid())
  name        String        @unique
  description String?
  price       Float
  currency    String
  interval    String // e.g., "month", "year"
  features    String[]      // List of features included
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  subscriptions Subscription[]
}

model Subscription {
  id               String    @id @default(uuid())
  userId           String    @unique // One subscription per user
  planId           String
  plan             Plan      @relation(fields: [planId], references: [id])
  startDate        DateTime
  endDate          DateTime? // Null for lifetime or trial, or end of current period
  status           String    // e.g., "active", "cancelled", "expired"
  paymentMethodId  String?   // Link to payment method if applicable
  externalId       String?   @unique // ID from payment gateway
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id])
}

// User model snippet (assuming it exists)
model User {
  id          String    @id @default(uuid())
  // ... other user fields
  subscription Subscription?
}
```

This schema establishes a one-to-one relationship between a `User` and their `Subscription`, and a many-to-one relationship between `Subscription` and `Plan`.

### Workflow

A typical user subscription process involves several steps handled by the subscription module:

```mermaid
graph TD
  A[User Selects Plan] --> B[Initiate Checkout]
  B --> C[Subscription Controller]
  C --> D[Subscription Service]
  D --> E[Payment Gateway API]
  E --> F[Payment Success Callback]
  F --> D
  D --> G[Create Subscription Record]
  G --> H[Database]
```

### Integration with Architecture

The subscription module (`src/modules/subscriptions/`) integrates with the overall NestJS architecture as follows:

1.  **API Layer:** Provides RESTful endpoints (`SubscriptionController`) for users to view plans, initiate subscriptions, manage their current subscription, and handle payment gateway webhooks/callbacks.
2.  **Service Layer:** Contains the core business logic (`SubscriptionService`) for interacting with the database (via Prisma Client), communicating with external payment gateways (if integrated), validating requests, and managing subscription states (active, cancelled, expired).
3.  **Database Layer:** Utilizes Prisma Client to interact with the database, persisting `Plan` and `Subscription` data as defined in `prisma/schema.prisma`.
4.  **User Module:** Depends on the User module to identify the user performing subscription actions and link subscriptions to user accounts.
5.  **Payment Integration:** Relies on a separate payment processing service or module to handle actual transactions. The subscription module manages the state *after* payment confirmation.
6.  **Other Modules:** Other parts of the application (e.g., feature modules) can inject `SubscriptionService` or query the database directly to check a user's current plan and determine feature access.

Sources:
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/subscriptions" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/subscriptions/</a>, <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/prisma/schema.prisma" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">prisma/schema.prisma</a></p>

---

<a id='page-6'></a>

## Monitoring and Health Checks

### Related Files

- `MONITORING.md`
- `prometheus/`
- `grafana/`
- `docker-compose.monitoring.yml`
- `src/modules/monitoring/`
- `src/modules/health/`

### Related Pages

Related topics: [System Architecture](#page-2)

Monitoring and Health Checks in this template provide mechanisms to observe the application's state, performance, and availability. This includes exposing metrics for collection by monitoring systems and providing endpoints to verify the health of various application components and external dependencies.

The purpose is to ensure the application is running correctly, identify potential issues before they impact users, and provide data for performance analysis and capacity planning. Health checks offer a quick way for orchestration systems (like Kubernetes or Docker Swarm) or load balancers to determine if an instance is ready to receive traffic or needs to be restarted. Monitoring metrics provide detailed insights into resource usage, request latency, error rates, and other key performance indicators.

### Key Components and Files

*   **`src/modules/health/`**: Contains the NestJS module and controller for exposing health check endpoints. This typically uses the `@nestjs/terminus` package to check the status of the application, database connections, memory usage, etc.
*   **`src/modules/monitoring/`**: Contains the NestJS module and controller for exposing application metrics, often in a format suitable for Prometheus. This might also leverage `@nestjs/terminus` or a dedicated metrics library.
*   **`docker-compose.monitoring.yml`**: A separate Docker Compose file defining services for Prometheus and Grafana. This allows running the monitoring stack alongside the application.
*   **`prometheus/`**: Directory containing configuration files for the Prometheus server, such as `prometheus.yml` which specifies targets to scrape metrics from (e.g., the NestJS application's monitoring endpoint).
*   **`grafana/`**: Directory containing configuration files for Grafana, such as data source configurations (pointing to Prometheus) and potentially dashboard definitions.
*   **`MONITORING.md`**: Documentation file explaining how to set up, configure, and use the monitoring and health check features, including running the Docker Compose services and accessing Grafana dashboards.

### Health Check Example

The `src/modules/health/health.controller.ts` file defines the `/health` endpoint.

```typescript
// src/modules/health/health.controller.ts
import { Controller, Get } from '@nestjs/common';
import {
  HealthCheckService,
  HttpHealthIndicator,
  HealthCheck,
  TypeOrmHealthIndicator,
} from '@nestjs/terminus';

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
    private db: TypeOrmHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),
      () => this.db.pingCheck('database'),
      // Add more checks here (e.g., memory, disk)
    ]);
  }
}
```
This controller uses `HealthCheckService` to run multiple indicators, such as checking an external URL (`nestjs-docs`) and the database connection (`database`).

### Monitoring Metrics Example

The `src/modules/monitoring/monitoring.controller.ts` file exposes metrics, often at an endpoint like `/metrics`.

```typescript
// src/modules/monitoring/monitoring.controller.ts
import { Controller, Get } from '@nestjs/common';
import { PrometheusController } from '@willsoto/nestjs-prometheus';

@Controller()
export class MonitoringController extends PrometheusController {
  @Get('/metrics')
  index() {
    return super.index();
  }
}
```
This example shows a simple controller extending a Prometheus-specific controller to expose metrics collected by the Prometheus module.

### Monitoring Stack Flow

The standard setup involves the application exposing metrics, Prometheus scraping them, and Grafana visualizing data from Prometheus.

```mermaid
graph TD
  A[NestJS App] -->|Exposes /metrics| B[Prometheus Server]
  B -->|Scrapes Data| C[Time-Series DB]
  D[Grafana] -->|Queries Data| B
  D -->|Displays Dashboards| E[User]
```

### Integration with Architecture

The monitoring and health check features integrate into the NestJS architecture as standard modules (`HealthModule`, `MonitoringModule`). These modules are imported into the main application module (`AppModule`) and their controllers expose specific HTTP endpoints (`/health`, `/metrics`).

The Prometheus and Grafana components are typically run as separate services, often orchestrated via `docker-compose.monitoring.yml`. Prometheus is configured to scrape the `/metrics` endpoint exposed by the NestJS application instance(s). Grafana is configured with Prometheus as a data source to build dashboards for visualizing the collected metrics. This separation keeps the monitoring infrastructure independent of the application deployment itself, while using standard interfaces (HTTP endpoints) for data collection.

Sources:
<p>Sources: <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/MONITORING.md" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">MONITORING.md</a> <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/prometheus" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">prometheus/</a> <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/grafana" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">grafana/</a> <a href="https://github.com/phuongwd/nestjs-starter-template/blob/main/docker-compose.monitoring.yml" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">docker-compose.monitoring.yml</a> <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/monitoring" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/monitoring/</a> <a href="https://github.com/phuongwd/nestjs-starter-template/tree/main/src/modules/health" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline">src/modules/health/</a></p>

---

